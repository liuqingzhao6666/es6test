<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			/*generator  实际应用，在 redux上 使用的非常多*/
			/*
			generator(生成器)，是属于es6的扩展语法。解决了两方面的问题：1.迭代器(循环) 2.解决异步编程的回调地狱问题
			generator 可以认为是一个状态机，内部封装了多种状态，等着用户去调用
			语法：1.函数名前面需要加星号；2.函数内部需要使用 yield关键字返回值
				generator函数的调用，必须使用 next方法
			*/
		   
		   //一.generator基础
		   //1.实例
		   // function * hello (){
			  //  console.log("这是第一个生成器实例");
		   // }
		   // //调用
		   // //hello();//必须进一步调用 next，才能出发方法
		   // hello().next();
		   
		   // //2.实例2
		   // function * hello2(){
			  //  yield "hello";
			  //  yield "hi";
			  //  return;
		   // }
		   // var h = hello2();
		   // console.log(h.next());//?{value: "hello", done: false}
		   // console.log(h.next());//?{value: "hi", done: false}
		   // console.log(h.next());//?{value: undefined, done: true}
		   //总结：每次执行.next();都会弹出一个最新的状态值；如果弹出的状态值为undefined时，就表示迭代器已经完成
		   
		   //二.generator 和迭代器
		   //1.实例
		   // function * hi(){
			  //  yield "hello";
			  //  yield "hi";
			  //  yield "11111";
			  //  yield "aaaa";
			  //  return;
		   // }
		   // var h = hi();
		   // for(var value of h){
			  //  console.log(value); //hello  hi  11111 aaaa
		   // }
		   //迭代器，每次输出 value的值，如果迭代结束就不再输出了，不会输出   undefined
		   
		   //2.实例
		   // function * gen(x,y){
			  //  let z = yield x+y;
			  //  console.log("z:"+z);
			  //  let result = yield z*x;
			  //  return result;
		   // }
		   // var g = gen(5,6);
		   // console.log(g.next());//?{value: 11, done: false}
		   // console.log(g.next());//?{value: NaN, done: false}  第一次的x+y的值没有保存，第二次调用时z的值是 undefined
		   
		   
		   // function * gen(x,y){
		   // 			   let z = yield x+y;
		   // 			   console.log("z:"+z);
		   // 			   let result = yield z*x;
		   // 			   return result;
		   // }
		   // var g = gen(5,6);
		   // console.log(g.next());//?{value: 11, done: false}
		   // console.log(g.next(11));//next()里面可以传参数
		   
		   function * gen(x,y){
		   			   let z = yield x+y;
		   			   console.log("z:"+z);
		   			   let result = yield z*x;
		   			   return result;
		   }
		   var g = gen(10,20);
		   let nn = g.next();
		   console.log(nn);//?{value: 11, done: false}
		   console.log(g.next(nn.value));//next()里面可以传参数
		   //总结：nn.value 就解决了无论上次的运行结果是什么，都可以作为下一次的值传入
		   
		   
		   
		</script>
	</body>
</html>
